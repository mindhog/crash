
import crack.io cout, cerr;
import crash eval, parseString;

@import crack.ann assert;

@assert(eval('format foo bar') == 'foobar');
@assert(eval('format wrong; format foo bar') == 'foobar');
@assert(eval('format wrong\nformat foo bar') == 'foobar');
@assert(eval('format {first {second}} {\\{third}') == 'first {second}\\{third');
@assert(eval('var x foobar; format $x') == 'foobar');
@assert(eval('var f format; $f cmdnames') == 'cmdnames');

# Verify interpolated expressions.
@assert(eval('var a 100; set a [format $a 1]; format $a') == '1001');
@assert(eval('var a 100; set a [format $a]; format $a') == '100');

# Verify that functions work and that we can access variables from parent contexts.
@assert(eval('var a 100; def f {} { format $a; }; f') == '100');
@assert(eval('def f {a b} { format $a $b }; f foo bar') == 'foobar');
@assert(eval('var a outer; def f {} { var a inner; format $a }; f') == 'inner');

# Add this back once we've got comments.
#@assert(eval('# comment!!!\nformat foo') == 'foo');

# Add this back once we can do 'var a [cmd]'
expr := I'
    def f {} {
        var x 1;
        def g {} {
            var y $x;
            set x 2;
            give $x
        }
    }
    var g [f]
    var x [g]
    give $x
    ';
# XXX Also try [[f]] in the example above, I think that should work...
@assert(eval(expr) == '2');

cout `ok\n`;


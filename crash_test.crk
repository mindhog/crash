
import crack.io cout, cerr;
import crack.lang Exception;
import crash eval, parseString, CrashError;

@import crack.ann assert;

@assert(eval('format foo bar') == 'foobar');
@assert(eval('format wrong; format foo bar') == 'foobar');
@assert(eval('format wrong\nformat foo bar') == 'foobar');
@assert(eval('format {first {second}} {\\{third}') == 'first {second}\\{third');
@assert(eval('var x foobar; format $x') == 'foobar');
@assert(eval('var f format; $f cmdnames') == 'cmdnames');

# Verify interpolated expressions.
@assert(eval('var a 100; set a [format $a 1]; format $a') == '1001');
@assert(eval('var a 100; set a [format $a]; format $a') == '100');

# Verify that functions work and that we can access variables from parent contexts.
@assert(eval('var a 100; def f {} { format $a; }; f') == '100');
@assert(eval('def f {a b} { format $a $b }; f foo bar') == 'foobar');
@assert(eval('var a outer; def f {} { var a inner; format $a }; f') == 'inner');

# Add this back once we've got comments.
#@assert(eval('# comment!!!\nformat foo') == 'foo');

# Add this back once we can do 'var a [cmd]'
expr := I'
    # Here is a comment.
    def f {} {
        var x 1;
        def g {} {
            var y $x;
            set x 2;
            give $x
        }
    }

    # More commented text.
    # Multiple lines, just for the heck of it.
    var g [f]
    var x [g]
    give $x
    ';
# XXX Also try [[f]] in the example above, I think that should work...
@assert(eval(expr) == '2');

@assert(eval("give 'foo bar'") == 'foo bar');
@assert(eval("give '\t\n\a\r\b'") == '\t\n\a\r\b');

# Hex escapes.
@assert(eval("give '\\x1fa'") == '\x1fa');
@assert(eval("give '\\x1f'") == '\x1f');
@assert(eval("give '\\x1F'") == '\x1f');
@assert(eval("give '\\x1'") == '\x01');
@assert(eval("give '\\x1\\t'") == '\x01\t');
@assert(eval("give '\\x1G'") == '\x01G');

# Octal escapes.
@assert(eval("give '\\o001'") == '\001');
@assert(eval("give '\\001'") == '\001');
@assert(eval("give '\\08'") == '\08');
@assert(eval("give '\\018'") == '\0018');
@assert(eval("give '\\0\\t'") == '\0\t');

# Multiple hex/octal escapes, ensure that the accumulator is cleared at
# the beginning of each.
@assert(eval("give '\\x10\\21\\o022'") == '\x10\x11\x12');

# Test objects.
@assert(eval("var o [object { var a foo; def f {} { give $a } }]; $o f") ==
         'foo'
        );

try {
    eval("var val [blech]");
    cerr `FAILED to throw exception in interpolated command.\n`;
} catch (Exception ex) {
}

# If statements
@assert(eval("if {give 1} {give yes}") == 'yes');
@assert(eval("if {give ''} {give fail}") == null);
@assert(eval("if {give ''} {give fail} else {give yes}") == 'yes');
@assert(eval("if {give ''} {give fail} elif {give true} {give yes}") ==
         'yes'
        );
@assert(eval("if {give ''} {give fail1} elif {give true} {give yes} else "
              "{give fail2}"
             ) == 'yes'
        );
@assert(eval("if {give ''} {give fail1} elif {give ''} {give fail2} else "
              "{give yes}"
             ) == 'yes'
        );

# Import.
@assert(eval("import [object { var x 1; var y 2}] x y; format $x $y") == '12');

# Error locations.
try {
    eval("\n\nfoo");
    @assert(false);
} catch (CrashError ex) {
    @assert(ex.stack && ex.stack[0].lineNum == 3);
}

# Verify that a variable at the end of a string has the correct line number
# associated with it.
try {
    eval("print $bogus
    ");
} catch (CrashError ex) {
    @assert(ex.stack && ex.stack[0].lineNum == 1);
}

# Verify that line numbers work for nested blocks.
try {
    eval("
        if {give 1} {
            print $bogus
        }
    ");
} catch (CrashError ex) {
    @assert(ex.stack.count() == 4 && ex.stack[0].lineNum == 3);
}

cout `ok\n`;


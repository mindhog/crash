
import crack.ascii isDigit, isSpace;
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.io cout, cerr, Formatter, FStr, StringFormatter;
import crack.functor Functor2;
import crack.lang AppendBuffer, Exception;

class EvalContext;

## A value stored in an EvalContext.  We don't store data values directly,
## they always are evaluated.  In this way, we can do things like override
## evaluation.
@abstract class Value {

    ## Returns the value of the object.
    @abstract Object evaluate(EvalContext context);

    ## Set the value.
    @abstract void set(Object value);

    ## Invoke the function associated with the value with the given arguments.
    @abstract Object invoke(EvalContext context, Array[Object] args);
}

# A stack frame.
class Frame {
    Frame parent;
    HashMap[String, Value] vars = {};

    ## The current block.
    Array[Value] block;

    ## The instruction pointer.  This is a an index into block indicating the
    ## next instruction to evaluated.
    uint ip;

    @final Value lookUp(String name) {
        val := vars.get(name, null);
        if (val is null) {
            if (parent)
                return parent.lookUp(name);
            else
                return null
        } else {
            return val;
        }
    }

    @final void define(String name, Value val) {
        vars[name] = val;
    }

    @final void set(String name, Object val) {
        holder := lookUp(name);
        if (holder is null)
            throw Exception(FStr() I`Undefined variable $name can not be \
                                     set (use "var" instead)`
                            );
        holder.set(val);
    }
}

class EvalContext {

    ## The current stack frame.
    Frame frame = {};

    ## Set this to true to cause evaluation to yield.
    bool yield;

    @final Value lookUp(String name) {
        return frame.lookUp(name);
    }

    @final void define(String name, Value val) {
        frame.define(name, val);
    }

    @final void set(String name, Object val) {
        frame.set(name, val);
    }
}

class SimpleValue : Value {
    Object __val;

    oper init(Object val) : __val = val {}

    Object evaluate(EvalContext context) {
        return __val;
    }

    Object invoke(EvalContext context, Array[Object] args) {
        # Assume this is a functor.
        val := evaluate(context);
        func := Functor2[Object, EvalContext, Array[Object]].cast(val);
        return func(context, args);
    }

    void set(Object value) {
        __val = value;
    }
}

@abstract class Builtin : Value {
    Object evaluate(EvalContext context) {
        return this;
    }

    void set(Object val) {
        throw Exception('You can not set a builtin.');
    }
}

class PrintCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        for (arg :in args)
            cout `$arg`;
        return null;
    }
}

class FormatCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        StringFormatter tmp = {};
        for (arg :in args) {
            tmp `$arg`;
        }

        return tmp.string();
    }
}

class VarCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('usage: var <var> <value>');

        String var = String.cast(args[0], null);
        if (var is null)
            throw Exception('first argument of var must be a string');

        Object val = args[1];
        context.define(var, SimpleValue(val));
        return val;
    }
}

class SetCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('usage: set <var> <value>');

        String var = String.cast(args[0], null);
        if (var is null)
            throw Exception('first argument of set must be a string');

        Object val = args[1];
        context.set(var, val);
        return val;
    }
}

## A word of syntax.  Quoted strings, blocks, and barewords are all terms.
@abstract class Term {
    @abstract Object evaluate(EvalContext context);
}

## A single command.
class Command : Value {
    Term command;
    Array[Term] args = {};

    oper init(Term command) : command = command {}

    String __getCommand(EvalContext context) {
        # Evaluate the command and convert its value to a string if it isn't
        # one already.
        # TODO: split Command into LiteralCommand and EvaledCommand.
        cmdobj := command.evaluate(context);
        String cmdstr;
        if ( !(cmdstr = String.cast(cmdobj, null)) )
            cmdstr = FStr() `$cmdobj`;
        return cmdstr;
    }

    Object evaluate(EvalContext context) {

        cmdVal := context.lookUp(__getCommand(context));
        if (!cmdVal)
            throw Exception(FStr() `Invalid command: $command\n`);

        Array[Object] evaledArgs = {};
        for (arg :in args)
            evaledArgs.append(arg.evaluate(context));
        return cmdVal.invoke(context, evaledArgs);
    }

    # This is really just to implement Value's interface, but it has the
    # ineresting side-effect of letting us evaluate a command against a fully
    # evaluated set of arguments.
    Object invoke(EvalContext context, Array[Object] args) {
        cmdVal := context.lookUp(__getCommand(context));
        if (!cmdVal)
            throw Exception(FStr() `Invalid command: $command\n`);

        return cmdVal.invoke(context, args);
    }

    void set(Object value) {
        throw Exception('You may not set the value of a command.');
    }

    void formatTo(Formatter out) {
        out `$command`;
        for (arg :in args)
            out ` $arg`;
    }
}

## A Block of commands.
class Block {
    Array[Value] commands = {};

    Object evaluate(EvalContext context) {
        context.yield = false;
        context.frame.block = commands;
        context.frame.ip = 0;
        Object result;
        while (context.frame.ip < commands.count()) {
            result = commands[context.frame.ip++].evaluate(context);
            if (context.yield)
                return null;
        }
        return result;
    }

    @final void add(Value value) {
        commands.append(value);
    }

    void formatTo(Formatter out) {
        for (cmd :in commands)
            out `$cmd\n`;
    }
}

## An interpolated command: [do something]
class InterpolatedCommand : Term {
    Block contents;

    Object evaluate(EvalContext context) {
        return contents.evaluate(context);
    }
}

## A string without variable interpolations.
class LiteralString : Term {
    String val;

    oper init(String val) : val = val {}

    Object evaluate(EvalContext context) {
        return val;
    }

    void formatTo(Formatter out) {
        out `$(val.getRepr())`;
    }
}

class VarRef : Term {
    String varName;

    oper init(String varName) : varName = varName {}

    Object evaluate(EvalContext context) {
        holder := context.lookUp(varName);
        if (!holder)
            throw Exception(FStr() `Undefined variable $varName`);
        return holder.evaluate(context);
    }

    void formatTo(Formatter out) {
        out `\$$varName`;
    }
}

#class InterpolatedString : Term {
#    Array[StringTerm
#    String value;
#
#    Object evaluate(EvalContext context) {
#        AppendBuffer result = {};
#        pos := value.lfind('$');
#        if (pos)
#            result.extend(value.slice(0, pos));

const int
    TOK_EOF = 0,
    TOK_STR = 1,
    TOK_SEMI = 2,
    TOK_VAR = 3;

class Token {
    int type;
    String text;

    oper init(int type, String text) : type = type, text = text {}
}

class Toker {
    String contents;
    uint pos;

    oper init(String contents) : contents = contents {}

    Token getToken() {
        AppendBuffer result = {128};
        const int
            BASE = 0,

            # A word is a sequence of non-whitespace chars which may contain
            # interpolation sequences.
            WORD = 1,

            BRACK = 2,
            BRACK_ESC = 3,

            VAR = 4;
        int state = BASE;

        # Number of levels of curly bracket nesting.
        int count;

        while (true) {
            byte ch;
            if (pos == contents.size)
                ch = 0;
            else
                ch = contents[pos++];
            if (state == BASE) {
                if (!ch)
                    return Token(TOK_EOF, null);
                if (ch == b'\n' || ch == b';')
                    return Token(TOK_SEMI, String(1, ch));

                if (ch == b'{') {
                    state = BRACK;
                    count = 1;
                } else if (ch == b'$') {
                    state = VAR;
                } else if (!isSpace(ch)) {
                    result.append(ch);
                    state = WORD;
                }
            } else if (state == WORD) {
                if (isSpace(ch) || !ch || ch == b';') {
                    # Back up so we can catch it if it's a newline.
                    if (ch) --pos;
                    return Token(TOK_STR, String(result, true));
                } else {
                    result.append(ch);
                }
            } else if (state == BRACK) {
                if (ch == b'\\') {
                    state = BRACK_ESC;
                } else if (ch == b'{') {
                    ++count;
                } else if (ch == b'}') {
                    if (!--count)
                        return Token(TOK_STR, String(result, true));
                } else if (!ch) {
                    throw Exception('Premature end of file in bracketed '
                                    'string.');
                }
                result.append(ch);
            } else if (state == BRACK_ESC) {
                result.append(ch);
                state = BRACK;
            } else if (state == VAR) {
                if (ch >= b'a' && ch <= b'z' ||
                    ch >= b'A' && ch <= b'Z' ||
                    ch == b'_' || isDigit(ch)
                    )
                    result.append(ch);
                else
                    return Token(TOK_VAR, String(result, true));
            }
        }

        return null;
    }
}

class Parser {
    Toker toker;

    oper init(String contents) : toker(contents) {}

    Block parse() {
        Block result = {};
        Command cmd;

        while (true) {
            tok := toker.getToken();
            if (tok.type == TOK_EOF) {
                break;
            } else if (tok.type == TOK_STR) {
                if (!cmd)
                    cmd = Command(LiteralString(tok.text));
                else
                    cmd.args.append(LiteralString(tok.text));
            } else if (tok.type == TOK_SEMI) {
                # Add the current command.
                if (cmd) {
                    result.add(cmd);
                    cmd = null;
                }
            } else if (tok.type == TOK_VAR) {
                if (cmd)
                    cmd.args.append(VarRef(tok.text));
                else
                    cmd = Command(VarRef(tok.text));
            }

        }

        # Add the last command.
        if (cmd)
            result.add(cmd);

        return result;
    }
}

## Returns a new EvalContext containing all of the normal builtin functions.
EvalContext createRootContext() {
    ctx := EvalContext();
    ctx.define('print', PrintCmd());
    ctx.define('format', FormatCmd());
    ctx.define('var', VarCmd());
    ctx.define('set', SetCmd());
    return ctx;
}

Block compile(String expr) {
    Parser parser = {expr};
    return parser.parse();
}

Object eval(Block block, EvalContext context) {
    if (context is null)
        return block.evaluate(createRootContext());
    else
        return block.evaluate(context);
}

Object eval(Block block) { return eval(block, null); }

Object eval(String expr, EvalContext context) {
    block := compile(expr);
    return eval(block, context);
}

Object eval(String expr) { return eval(expr, null); }

# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import crack.ascii isDigit, isSpace, strip, wsplit;
import crack.fs makePath;
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.fieldset FieldSet, HashMapFieldSet;
import crack.functor Functor0, Functor2;
import crack.io cout, cerr, Formatter, FStr, StringFormatter;
import crack.lang cmp, AppendBuffer, Exception, SubString;
import crack.process Process;
import crack.strutil StringArray;

import .types BoolObj, IntObj, Number;

@import crack.ann cvars, define, impl, interface;
@import crack.fieldset_ann fieldset_accessors;

class EvalContext;

@export_symbols ValueConverter, API, PPI;

## A source code location.
class SrcLoc {
    int lineNum;
    oper init(int lineNum) : lineNum = lineNum {}

    void formatTo(Formatter out) { out `line $lineNum` }
}

class CrashError : Exception {
    Array[SrcLoc] stack = {};

    oper init(SrcLoc loc, String text) : Exception(text) {
        stack.append(loc);
    }

    void formatTo(Formatter out) {
        for (int i = stack.count() - 1; i >= 0; --i)
            out `$(stack[i])\n`;
        Exception.formatTo(out);
    }
}

## Type specifier for ParmInfo.
class TypeSpec {

    ## The name of the type in a form suitable for use in documentation.
    ##
    ## This should be a "fully qualified" type name.
    String oper .desc() { return '<Undefined>' }
}

## Type specifier that can be used for primitive types.
class PrimTypeSpec : TypeSpec {
    @cvars {
        ## The primitive class used for the type.
        Class cls;
    }

    String oper .desc() { return String(cls.name) }

    int cmp(Object other) {
        if (this is other)
            return 0;
        if (o := PrimTypeSpec.cast(other))
            return uintz(cls) - uintz(o.cls);
        else
            return Object.cmp(other);
    }
}

const ANY_TYPE := TypeSpec();

class ParmInfo;

## Interface for classes that can be added to a Formatter field set to provide
## special formatting for ParmInfo objects.
##
## Implement this interface and then attach it to a formatter to override the
## default formatting in a context.
@interface ParmInfoFormatter {
    @fieldset_accessors(ParmInfoFormatter);

    @abstract void format(Formatter out, ParmInfo parmInfo);
}

## Interface for defining parameter initializers.
class Initializer {}

## Parameter information.
##
## Used for documentation generation and generation of definitions for
## compile-time checking.
class ParmInfo {
    @cvars {
        ## Parameter name.
        String name;

        ## Parameter type definition.
        TypeSpec type;

        ## True if the parameter matches multiple positional arguments.
        bool mult;

        ## If specified, this is an initializer for creating the default value of
        ## the parameter when the parameter is not specified.
        Initializer defaultInitializer;
    }

    ## Create the default ParmInfo object, which is just a single, multi
    ## argument of any type.
    @static ParmInfo createDefault() {
        return ParmInfo('arg', ANY_TYPE, true, null);
    }

    ## Create a ParmInfo for a primitive type parameter with no initializer.
    @static ParmInfo create(String name, Class cls) {
        return ParmInfo(name, PrimTypeSpec(cls), false, null);
    }

    @static ParmInfo create(String name, Class cls, Initializer init) {
        return ParmInfo(name, PrimTypeSpec(cls), false, init);
    }

    ## Create a ParmInfo for a primitive type parameter with no initializer
    ## and optional "multiple" semantics.
    @static ParmInfo create(String name, Class cls, bool mult) {
        return ParmInfo(name, PrimTypeSpec(cls), mult, null);
    }

    ## Create a non-multiple ParmInfo with the given typespec.
    @static ParmInfo create(String name, TypeSpec spec) {
        return ParmInfo(name, spec, false, null);
    }

    void formatTo(Formatter out) {
        if (formatter := ParmInfoFormatter.get(out)) {
            formatter.format(out, this);
            return;
        }

        if (type is ANY_TYPE)
            out `$name`;
        else
            out `$name:$(type.desc)`;
        if (defaultInitializer)
            out `=$defaultInitializer`;
        if (mult)
            out `...`;
    }

    int cmp(Object other) {
        if (this is other)
            return 0;
        if (o := ParmInfo.cast(other, null)) {
            rc := cmp(name, o.name); if (rc) return rc;
            rc = cmp(type, o.type); if (rc) return rc;
            rc = cmp(mult, o.mult); if (rc) return rc;
            return cmp(defaultInitializer, o.defaultInitializer);
        } else {
            return Object.cmp(other);
        }
    }
}

## Paramter initialize from a constant.
class ConstInitializer : Initializer {
    @cvars {
        Object val;
    }

    void formatTo(Formatter out) { out `$val` }
}

const NULL_DEFAULT := ConstInitializer(null);

alias PPI = ParmInfo.create;
alias API = Array[ParmInfo];

const _DEFAULT_PARM_LIST := Array[ParmInfo]![ParmInfo.createDefault()];

## A value stored in an EvalContext.  We don't store data values directly,
## they always are evaluated.  In this way, we can do things like override
## evaluation.
@abstract class Value {

    ## Returns the value of the object.
    @abstract Object evaluate(EvalContext context);

    ## Set the value.
    @abstract void set(Object value);

    ## Invoke the function associated with the value with the given arguments.
    @abstract Object invoke(EvalContext context, Array[Object] args);

    ## Returns the source location for a value.  This exists primarily because
    ## Block is a sequence of Value objects, which seems questionable in
    ## retrospect.
    SrcLoc getSrcLoc() { return SrcLoc(0) }

    ## Returns the doc-string for the value.
    String getDoc() { return '' }

    ## Returns the list of ParmInfo objects defining the paramter list.
    ##
    ## By default, this is just an array containing a single default ParmInfo
    ## object, indicating that the value accepts any list of arguments.
    Array[ParmInfo] getParmInfo() { return _DEFAULT_PARM_LIST }
}

## A variable dictionary.
alias VarDict = HashMap[String, Value];

## A lexical context.
class LexCtx {
    ## The parent of a LexCtx is the LexCtx of the context in which the
    ## function is defined.
    LexCtx parent;

    ## The variable dictionary.
    VarDict __vars = {};

    oper init() {}
    oper init(LexCtx parent) : parent = parent {}
    oper init(LexCtx parent, VarDict vars) : parent = parent, __vars = vars {}

    @final VarDict oper .vars() { return __vars }

    @final Value lookUp(String name) {
        val := __vars.get(name, null);
        if (val is null) {
            if (parent !is null)
                return parent.lookUp(name);
            else
                return null
        } else {
            return val;
        }
    }

    @final void define(String name, Value val) {
        __vars[name] = val;
    }

    @final void set(String name, Object val) {
        holder := lookUp(name);
        if (holder is null)
            throw Exception(FStr() I`Undefined variable $name can not be \
                                     set (use "var" instead)`
                            );
        holder.set(val);
    }

    ## Utility function, dumps up to n levels of the Lexical context stack
    ## starting with this node.
    @final void dump(int n) {
        cur := this;
        cerr `==== stack frame ====\n`;
        while (cur !is null && n) {
            temp := FStr() `$(cur.vars)`;
            if (temp.size > 30)
                temp = temp.slice(0, 30);
            temp = wsplit(temp).join(' ');
            cerr `$(uintz(cur)) $temp\n`;
            cur = cur.parent;
            --n;
        }

        if (cur !is null)
            cerr `stack continues!`;
    }

    ## Iterate over the set of definitions in the lexical context.
    ##
    ## Note that this does not iterate over definitions in the parent lexical
    ## context.
    VarDict.Iter iter() {
        return __vars.iter();
    }
}

# A stack frame.
class Frame {
    Frame parent;

    ## The lexical context, which wraps the variable dictionary.  'vars'
    ## tracks its own parent lineage which typically mirrors that of the
    ## Frame except across a function call: in a function call, the parent of
    ## the frame traces the runtime call stack. But the parents of the var
    ## dict is the _lexical context_ in which the function is defined.
    LexCtx vars = {};

    ## The current block.
    Array[Value] block;

    ## The instruction pointer.  This is a an index into block indicating the
    ## next instruction to evaluated.
    uint ip;

    oper init() {}
    oper init(Frame parent) : parent = parent, vars = LexCtx(parent.vars) {}
    oper init(Frame parent, LexCtx vars) : parent = parent, vars = vars {}
}

# Function to return a Value for an object (essentially, encapsulating the
# object in something that we can invoke methods on).
alias ValueConverter = Functor2[Value, EvalContext, Object];

## A string that was parsed out of the source code (has an associated line
## number).
class StringLiteral : SubString {
    SrcLoc srcLoc;

    oper init(String rep, SrcLoc srcLoc) :
        SubString(rep, 0),
        srcLoc = srcLoc {
    }

    SrcLoc getErrorLoc() { return srcLoc }
}

class EvalContext {

    ## The current stack frame.
    Frame frame = {};

    ## Set this to true to cause evaluation to yield.
    bool yield;

    ## Mapping from class id to a function that returns a Value object for
    ## instances of that class.
    HashMap[uintz, ValueConverter] __classMap = {};

    oper init() {}

    ## Creates a toplevel EvalContext from another EvalContext.  This consists
    ## of a single frame with no parent (because it is at the bottom of the
    ## call stack) and the VarDict from the current frame of the other context
    ## (thus preserving the lexical context).
    oper init(EvalContext other) : frame = Frame(null, other.frame.vars) {}

    @final Value lookUp(String name) {
        return frame.vars.lookUp(name);
    }

    @final void define(String name, Value val) {
        frame.vars.define(name, val);
    }

    @final void set(String name, Object val) {
        frame.vars.set(name, val);
    }

    @final void dump() {
        frame.vars.dump(20);
    }

    @final void pushFuncFrame() {
        frame = Frame(frame);
    }

    @final void pushFuncFrame(LexCtx vars) {
        vars.parent = frame.vars;
        frame = Frame(frame, vars);
    }

    @final void popFuncFrame() {
        frame = frame.parent;
    }

    ## Define a value converter for the specified class.
    ##
    ## A ValueConverter converts an instance of a class to a Value object,
    ## effectively allowing methods to be called on it from crash.
    @final void defineConverter(Class cls, ValueConverter converter) {
        __classMap[uintz(cls)] = converter;
    }

    @final void defineConverter(Class cls,
                                function[Value, EvalContext, Object] converter) {
        __classMap[uintz(cls)] = ValueConverter.Wrap(converter);
    }

    ## Get the value converter for the specified class.
    @final ValueConverter getConverter(Class cls) {
        return __classMap.get(uintz(cls));
    }
}

Value createValueWrapper(EvalContext context, Object obj);

class SimpleValue : Value {
    Object __val;
    String __doc;

    oper init(Object val) : __val = val {}
    oper init(Object val, String doc) : __val = val, __doc = doc {}

    String getDoc() {
        return __doc ? __doc : '';
    }

    Object evaluate(EvalContext context) {
        return __val;
    }

    Object invoke(EvalContext context, Array[Object] args) {
        # Assume this is a Value.
        val := evaluate(context);
        func := Value.cast(val, null);
        if (func is null)
            # Failed to cast, create a value wrapper object for it.
            func = createValueWrapper(context, val);
        return func.invoke(context, args);
    }

    void set(Object value) {
        __val = value;
    }
}

@abstract class Builtin : Value {
    Object evaluate(EvalContext context) {
        return this;
    }

    void set(Object val) {
        throw Exception('You can not set a builtin.');
    }
}

class PrintCmd : Builtin {
    String getDoc() {
        return I'\
            Prints all of the arguments to standard output.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        for (arg :in args)
            cout `$arg`;
        return null;
    }
}

class FormatCmd : Builtin {
    String getDoc() {
        return I'\
            Returns a string containing all of the arguments formatted.

            This is the equivalent of the "print" command only instead of
            writing to standard output, it formats a string.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        StringFormatter tmp = {};
        for (arg :in args) {
            tmp `$arg`;
        }

        return tmp.string();
    }
}

## Run a Subprocess.
class ProcCmd : Builtin {
    String getDoc() {
        return I'\
            Run a subprocess, returns the result code.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        StringArray argv = {};
        for (arg :in args)
            argv.append(FStr() `$arg`);
        return IntObj(Process(argv, 0).run() & 0xff);
    }

    Array[ParmInfo] getParmInfo() {
        return Array[ParmInfo]![PPI('command', String),
                                PPI('arg', String, true)];
    }
}

## "give" just returns the value of its first argument.
class GiveCmd : Builtin {
    String getDoc() {
        return I'\
            Returns the value of the first argument.

            "give" is useful in cases where you want to return the value of a
            variable or constant from a block.  For example:

                var result [if {give $condition} {give true} else {give false}]

            Without the "give" statements above, the interpreter would assume
            that $condition, true and false were commands.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('"give" must have exactly one argument.');
        return args[0];
    }

    Array[ParmInfo] getParmInfo() {
        return Array[ParmInfo]![PPI('arg', ANY_TYPE)];
    }
}

class VarCmd : Builtin {
    String getDoc() {
        return I'\
            Define a variable.

            Defines a variable in the current context.  The variable will be
            visible in the current context and all nested contexts, and will
            be cleaned up when the context goes out of scope.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        ac := args.count();
        if (ac < 2 || ac > 3)
            throw Exception('usage: var <var> <value>');

        String var = String.cast(args[0], null);
        if (var is null)
            throw Exception('first argument of var must be a string');

        Object val = args[1];
        context.define(var,
                       SimpleValue(val, ac == 3 ? String.cast(args[2]) : null)
                       );
        return val;
    }

    API getParmInfo() {
        return API![PPI('varName', String),
                    PPI('value', ANY_TYPE),
                    PPI('documentation', String, NULL_DEFAULT)
                    ];
    }

}

class SetCmd : Builtin {
    String getDoc() {
        return I'\
            Set an existing variable to the given value.

            Note that the variable must have already been defined using the
            "var" command.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('usage: set <var> <value>');

        String var = String.cast(args[0], null);
        if (var is null)
            throw Exception('first argument of set must be a string');

        Object val = args[1];
        context.set(var, val);
        return val;
    }

    API getParmInfo() {
        return API![PPI('varName', String), PPI('value', ANY_TYPE)];
    }
}

# Numeric operations.
@define opcmd(cls, meth, op, doc) {
    class cls : Builtin {
        String getDoc() { return doc }
        Object invoke(EvalContext context, Array[Object] args) {
            if (!args)
                throw Exception('usage: ' $op ' <number> ...');

            accum := Number.convertNum(args[0]);
            for (arg :in args.subarray(1))
                accum = accum.meth(Number.convertNum(arg));
            return accum;
        }

        API getParmInfo() {
            return API![PPI('primary', Number), PPI('arg', Number)];
        }
    }
}

@opcmd(AddCmd, plus, +, 'Returns the sum of all arguments');
@opcmd(SubCmd, minus, -, 'Returns the first argument minus all others');
@opcmd(MulCmd, times, *, 'Returns the product of all arguments');
@opcmd(DivCmd, div, /,
       I'Returns the first argument divided by the second (and that divided
         by the third, and so on)');
@opcmd(ModCmd, mod, %,
       I'Returns the remainder of the first argument divided by the second
         (and that divided by the third, and so on)');

class EqualCmd : Builtin {
    String getDoc() {
        return I'\
            Returns true if its two arguments are equal, false if not.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('usage: == <val1> <val2>');

        return BoolObj(args[0] == args[1]);
    }

    API getParmInfo() {
        return API![PPI('val1', ANY_TYPE), PPI('val2', ANY_TYPE)];
    }
}

class NotEqualCmd : Builtin {
    String getDoc() {
        return I'\
            Returns true if its two arguments are not equal, false if not.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('usage: != <val1> <val2>');

        return BoolObj(args[0] != args[1]);
    }

    API getParmInfo() {
        return API![PPI('val1', ANY_TYPE), PPI('val2', ANY_TYPE)];
    }
}

## A crash object - this has its own variable dictionary that is injected as a
## stack frame when a method is invoked.
class Obj : Builtin {
    Obj parent;
    VarDict vars;

    oper init(VarDict vars) : vars = vars {}
    oper init() : vars() {}

    Object invoke(EvalContext context, Array[Object] args) {
        if (!args)
            return this;

        method := String.cast(args[0], null);
        if (!method)
            throw Exception('Method names must be strings.');

        methodObj := vars.get(method);
        if (!methodObj)
            throw Exception(FStr() `Undefined method: $method`);

        lexCtx := LexCtx(null, vars);
        context.pushFuncFrame(lexCtx);
        Object result;
        try {
            result = methodObj.invoke(context, args.subarray(1));
        } catch (Exception ex) {
            context.popFuncFrame();
            throw Exception(ex.text);
        }
        context.popFuncFrame();

        return result;
    }

    ## Define a name in the object's variable dictionary.
    @final void define(String name, Value val) {
        vars[name] = val;
    }

    void formatTo(Formatter out) {
        out `Obj($vars)`;
    }

    Object convertTo(Class cls) {
        return this.isa(cls) ? this : null;
    }
}

class ObjOf[T] : Obj {
    T __inst;
    oper init(T inst) : __inst = inst {}

    void formatTo(Formatter out) {
        out `$(__inst)`;
    }

    Object convertTo(Class cls) {
        if (T.isSubclass(cls))
            return __inst;
        else
            return Obj.convertTo(cls);
    }

    int cmp(Object other) {
        if (o := Obj.cast(other, null))
            return cmp(__inst, o.convertTo(Object));
        return cmp(__inst, other);
    }
}

Object convert(Object inst, Class cls) {
    if (obj := Obj.cast(inst, null))
        return obj.convertTo(cls);
    else
        return inst;
}

Value createValueWrapper(EvalContext context, Object obj) {
    if (obj && (converter := context.getConverter(obj.class)))
        return converter(context, obj);
    else
        return Obj();
}

## A word of syntax.  Quoted strings, blocks, and barewords are all terms.
@abstract class Term {
    @abstract Object evaluate(EvalContext context);
    @abstract SrcLoc getSrcLoc();
}

## A single command.
class Command : Value {
    Term command;
    Array[Term] args = {};

    oper init(Term command) : command = command {}

    Value __getCommand(EvalContext context) {
        # Evaluate the command and convert its value to a string if it isn't
        # one already.
        # TODO: split Command into LiteralCommand and EvaledCommand.
        cmdobj := command.evaluate(context);

        # If the command is already a value, just return it.
        if (valobj := Value.cast(cmdobj, null))
            return valobj;

        # Convert it to a string and do a lookup.
        String cmdstr;
        if ( !(cmdstr = String.cast(cmdobj, null)) ) {
            # The command isn't a string - see if there's a converter for it.
            if (converter := context.getConverter(cmdobj.class))
                return converter(context, cmdobj);
            else
                throw Exception(FStr() I`Object $cmdobj is not a string and \
                                         can not be converted to a value.`
                                );

        }
        cmdVal := context.lookUp(cmdstr);
        if (!cmdVal) {
            if (lit := StringLiteral.cast(cmdstr, null))
                throw CrashError(getSrcLoc(),
                                 FStr() `Invalid command: $cmdstr`
                                 );
            else
                throw Exception(FStr() `Invalid command: $cmdstr`);
        }

        return cmdVal;
    }

    Object evaluate(EvalContext context) {

        cmdVal := __getCommand(context);

        Array[Object] evaledArgs = {};
        for (arg :in args)
            evaledArgs.append(arg.evaluate(context));
        try {
            return cmdVal.invoke(context, evaledArgs);
        } catch (CrashError ex) {
            ex.stack.append(getSrcLoc());
            throw ex;
        } catch (Exception ex) {
            throw CrashError(getSrcLoc(), FStr() `evaluating $this: $ex`);
        }
    }

    # This is really just to implement Value's interface, but it has the
    # ineresting side-effect of letting us evaluate a command against a fully
    # evaluated set of arguments.
    Object invoke(EvalContext context, Array[Object] args) {
        cmdVal := __getCommand(context);
        return cmdVal.invoke(context, args);
    }

    void set(Object value) {
        throw Exception('You may not set the value of a command.');
    }

    void formatTo(Formatter out) {
        out `$command`;
        for (arg :in args)
            out ` $arg`;
    }

    SrcLoc getSrcLoc() {
        return command.getSrcLoc();
    }
}

## A Block of commands.
class Block {
    Array[Value] commands = {};

    Object evaluate(EvalContext context) {
        context.yield = false;
        context.frame.block = commands;
        context.frame.ip = 0;
        Object result;
        while (context.frame.ip < commands.count()) {
            command := commands[context.frame.ip++];
            try {
                result = command.evaluate(context);
            } catch (CrashError ex) {
                ex.stack.append(command.getSrcLoc());
                throw ex;
            }
            if (context.yield)
                return null;
        }
        return result;
    }

    @final void add(Value value) {
        commands.append(value);
    }

    void formatTo(Formatter out) {
        for (cmd :in commands)
            out `$cmd\n`;
    }
}

## An interpolated command: [do something]
class InterpolatedCommand : Term {
    Block contents;

    Object evaluate(EvalContext context) {
        return contents.evaluate(context);
    }

    SrcLoc getSrcLoc() {
        if (contents && contents.commands)
            return contents.commands[0].getSrcLoc();
        else
            return SrcLoc(0);
    }
}

## A string without variable interpolations.
class LiteralStringTerm : Term {
    StringLiteral val;

    oper init(String val, SrcLoc srcLoc) : val(val, srcLoc) {}

    Object evaluate(EvalContext context) {
        return val;
    }

    void formatTo(Formatter out) {
        out `$(val.getRepr())`;
    }

    SrcLoc getSrcLoc() {
        return val.srcLoc;
    }
}

class VarRef : Term {
    StringLiteral varName;

    oper init(StringLiteral varName) : varName = varName {}

    Object evaluate(EvalContext context) {
        holder := context.lookUp(varName);
        if (!holder)
            throw CrashError(varName.getErrorLoc(),
                             FStr() I`Undefined variable "$varName"`
                             );
        return holder.evaluate(context);
    }

    void formatTo(Formatter out) {
        out `\$$varName`;
    }

    SrcLoc getSrcLoc() { return varName.srcLoc }
}

## An interpolation expression - a block of the form "[ statements ... ]"
## Evaluates the block and returns the result.
class InterpExpr : Term {
    Block block;
    oper init(Block block) : block = block {}

    Object evaluate(EvalContext context) {
        vars := context.frame.vars;
        context.pushFuncFrame();
        context.frame.vars.parent = vars;

        result := block.evaluate(context);
        if (!context.yield)
            context.popFuncFrame();

        return result;
    }

    void formatTo(Formatter out) {
        out `[$block]`;
    }

    SrcLoc getSrcLoc() {
        if (block && block.commands)
            return block.commands[0].getSrcLoc();
        else
            return SrcLoc(0);
    }
}

#class InterpolatedString : Term {
#    Array[StringTerm
#    String value;
#
#    Object evaluate(EvalContext context) {
#        AppendBuffer result = {};
#        pos := value.lfind('$');
#        if (pos)
#            result.extend(value.slice(0, pos));

class ActiveFunc : Value {
    ## The function name.
    String name;

    ## Carries around the LexCtx from where the function was instantiated.
    LexCtx ownerVars;

    Array[String] argVars;
    Block body;
    String doc;

    oper init(String name, LexCtx ownerVars, Array[String] argVars,
              Block body,
              String doc
              ) :
        name = name,
        ownerVars = ownerVars,
        argVars = argVars,
        body = body,
        doc = doc {
    }

    Object evaluate(EvalContext context) {
        return this;
    }

    Object invoke(EvalContext context, Array[Object] args) {
        # Make sure we have the right number of arguments.
        if (args.count() != argVars.count())
            throw Exception(FStr() I`Wrong number of arguments (\
                                     $(argVars.count()) expected).`
                            );

        # Push a new stack frame.
        context.pushFuncFrame();

        # Chain variable lookups to the parent.
        context.frame.vars.parent = ownerVars;

        # Define all of the argument variables with their values.
        for (argIter :on args)
            context.define(argVars[argIter.index], SimpleValue(argIter.elem()));

        # Evaluate the function.
        result := body.evaluate(context);

        # If the function wasn't yielded, clean up the stack frame.
        if (!context.yield)
            context.popFuncFrame();

        return result;
    }

    String getDoc() {
        return doc ? doc : '';
    }

    void set(Object value) {
        throw Exception('Can not set a function');
    }

    void formatTo(Formatter out) {
        out `func $argVars $(doc ? doc.getRepr() : '') {\n$body}`
    }
}

Block parseString(String val, int lineNum);
Block parseString(String val);

## Parses a block argument.  Does not check for a valid index, but does verify
## that the argument can be casted to a string.
Block parseBlockArg(Array[Object] args, int index) {
    argVal := args[index];
    if (b := Block.cast(argVal, null))
        return b;

    if (s := StringLiteral.cast(argVal, null))
        return parseString(s, s.srcLoc.lineNum);

    argStr := String.cast(args[index], null);
    if (argStr is null)
        throw Exception('Block argument expected');
    return parseString(argStr);
}

## A function definition.  When invoked, these create an ActiveFunc.
class FuncDef : Value {

    String getDoc() {
        return I'\
            Define a function:
            def <function-name> <args> <body>
            def <function-name> <args> <documentation> <body>

            Define a function.  The arg list is simply a list of variable
            names, the body is a crash block.

            If provided, the documentation argument is a string to be
            displayed in the help text.  The brief help (displayed when
            listing help without an argument) is the text up to the first
            blank line, the complete help is all of the text in the string.
            ';
    }

    Object evaluate(EvalContext context) {
        return this;
    }

    void set(Object value) {
        throw Exception('Can not set a function definition value.');
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() < 3 || args.count() > 4)
            throw Exception(I'Bad function definition, should be def <args> \
                              <body> or def <args> <doc> <body>');
        name := String.cast(args[0]);
        funcArgs := wsplit(strip(String.cast(args[1])));
        cur := 2;
        String doc;
        if (args.count() == 4) {
            doc = String.cast(args[cur++], null);
            if (doc is null)
                throw Exception('String argument expected for doc.');
        }
        body := parseBlockArg(args, cur);

        # If there are no args, wsplit gives us [''], so remove that.
        if (funcArgs[0] == '')
            funcArgs.delete(0);

        # Create a function and register it.
        result := ActiveFunc(name, context.frame.vars, funcArgs, body, doc);
        context.define(name, result);

        return result;
    }
}

## Command to create an object.
class ObjectCmd : Builtin {
    String getDoc() {
        return I'\
            Create an object.

            The block is executed in the context of the object.  All variables
            created and functions defined become instance variables and
            methods of the new object.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Usage: object { statement... }');

        # Parse and evaluate the body, steal the variable dict from the
        # resulting stack frame.
        body := parseBlockArg(args, 0);
        context.pushFuncFrame();
        try {
            body.evaluate(context);
        } catch (Exception ex) {
            context.popFuncFrame();
            throw Exception(ex.text);
        }
        vars := context.frame.vars.vars;
        context.popFuncFrame();

        return Obj(vars);
    }

    API getParmInfo() {
        return API![PPI('block', Block)];
    }
}

## Command to import a set of names from an object.
class ImportCmd : Builtin {
    String getDoc() {
        return I'\
            Imports names from an object into the current context.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() < 2)
            throw Exception('Usage: import <object> <name> ...');

        obj := Obj.cast(args[0]);
        for (name :in args.subarray(1)) {
            nm := String.cast(name, null);
            context.define(nm, obj.vars[nm]);
        }
        return obj;
    }

    API getParmInfo() {
        return API![PPI('object', ANY_TYPE), PPI('name', String)];
    }
}

## Command to evaluate a file and return the module as an object. You can
## import symbols defined in the file from the result, for example:
##      import [evalfile foo.crash] bar baz
##
## Alternately, you can simply assign the result to a variable which becomes a
## sort of namespace:
##      var foo [evalfile foo.crash]
##      foo bar
##
## The file is evaluated in a subcontext of the current context, which
## isn't very good as it allows definitions to leak into the file's context.
class EvalfileCmd : Builtin {
    String getDoc() {
        return I'\
            Evaluates the file and returns the module as an object.

            You generally want to use "load_module" instead (which has similar
            semantics, but returns the existing module object if it has
            already been loaded).  Use "evalfile" to create new, discrete,
            instances of a module.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Usage: evalfile <filename>');

        name := String.cast(args[0]);
        contents := makePath(name).readAll();
        context.pushFuncFrame();
        parseString(contents).evaluate(context);
        if (!context.yield) {
            result := Obj(context.frame.vars.vars);
            context.popFuncFrame();
            return result;
        } else {
            return null;
        }
    }

    API getParmInfo() {
        return API![PPI('filename', String)];
    }
}

_moduleMap := HashMap[String, Obj]();

## Loads the named module if it is not already loaded and returns its module
## object.  This should be used in preference to evalfile for modules, as it
## reuses an existing instance of the module instead of loading a new one.
class LoadModuleCmd : Builtin {

    String getDoc() {
        return I'\
            Returns the named module as an object, loading the file (ala
            "evalfile") if it is not already loaded.

            You may import symbols defined in the file from the result, for
            example:
                import [load_module foo.crash] bar baz

            Alternately, you can simply assign the result to a variable which
            becomes a sort of namespace:
                var foo [load_module foo.crash]
                foo bar

            The file is evaluated in a subcontext of the current context.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Usage: evalfile <filename>');

        name := String.cast(args[0]);

        if (mod := _moduleMap.get(name))
            return mod;

        contents := makePath(name).readAll();
        context.pushFuncFrame();
        parseString(contents).evaluate(context);
        if (!context.yield) {
            result := Obj(context.frame.vars.vars);
            context.popFuncFrame();
            _moduleMap[name] = result;
            return result;
        } else {
            return null;
        }
    }

    API getParmInfo() {
        return API![PPI('filename', String)];
    }
}

## Evaluate a file in the current context.  Returns zero.
class SourceCmd : Builtin {
    String getDoc() {
        return I'\
            Evaluates a file in the current context, returns zero.
            ';
    }

     Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Usage: evalfile <filename>');

        name := String.cast(args[0]);
        contents := makePath(name).readAll();

        # Push a func frame using the existing variable set so any variables
        # defined in the source file are stored locally.
        context.pushFuncFrame(context.frame.vars);

        parseString(contents).evaluate(context);
        if (!context.yield) {
            result := Obj(context.frame.vars.vars);
            context.popFuncFrame();
            return result;
        } else {
            return null;
        }
    }

    API getParmInfo() {
        return API![PPI('filename', String)];
    }
}

## The "if" command.
##
## Note that we don't provide ParmInfo for this because its argument parsing
## is too complicated to be represented that way.
class IfCmd : Builtin {

    String getDoc() {
        return I'\
            The "if" statement: if <cond-block> <true-block> {[else|elif] ...}

            Returns the value of the condition that was chosen.
            ';
    }

    Object invoke(EvalContext context, Array[Object] args) {
        argCount := args.count();
        if (argCount < 2)
            throw Exception('usage: if <cond-block> <true-block> '
                             '{[else|elif] ...}'
                            );
        cond := parseBlockArg(args, 0);
        trueBlock := parseBlockArg(args, 1);

        # Evaluate the condition.
        context.pushFuncFrame();
        result := cond.evaluate(context);
        if (result is null && context.yield)
            return null;
        else if (result) {
            # Result is true, evaluate the block.
            result = trueBlock.evaluate(context);
            if (!context.yield)
                context.popFuncFrame();
            return result;
        }

        # Evaluate elif/else.
        int index = 2;
        while (index < argCount) {
            kw := String.cast(args[index], null);
            if (kw == 'else') {
                # Make sure we have exactly one more argument.
                if (argCount < index + 2)
                    throw Exception(FStr() I`Missing block after 'else'`);
                else if (argCount != index + 2)
                    throw Exception(FStr() I`Extra arguments after else block: \
                                            $(args.subarray(index + 2))`
                                    );

                # Do the else block.
                block := parseBlockArg(args, index + 1);
                result := block.evaluate(context);
                if (!context.yield)
                    context.popFuncFrame();
                return result;
            } else if (kw == 'elif') {
                # Make sure we have at least two more arguments.
                if (argCount < index + 2)
                    throw Exception('Missing condition or block after "elif"');

                cond = parseBlockArg(args, index + 1);

                # XXX Somehow when we resume, we're going to need to start
                # from this point instead of reevaluating the entire if
                # statement.
                result = cond.evaluate(context);
                if (result is null && context.yield)
                    return null;

                if (result) {
                    block := parseBlockArg(args, index + 2);
                    result = block.evaluate(context);
                    if (!context.yield)
                        context.popFuncFrame();
                    return result;
                }

                index += 3;
            } else {
                cerr `$args, $index, $kw\n`;
                throw Exception("'else' or 'elif' expected");
            }
        }

        if (!context.yield)
            context.popFuncFrame();
        return null;
    }
}

const int
    TOK_EOF = 0,
    TOK_STR = 1,
    TOK_SEMI = 2,
    TOK_VAR = 3,

    # Left and right square brackets.
    TOK_LBRACK = 4,
    TOK_RBRACK = 5;

class Token {
    int type;
    String text;
    int lineNum;

    oper init(int type, String text, int lineNum) :
        type = type,
        text = text,
        lineNum = lineNum {
    }

    void formatTo(Formatter out) {
        if (text)
            out `$text`;
        else if (type == TOK_EOF)
            out `<EOF>`;
        else
            out `:$type:`;
    }
}

class Toker {
    String contents;
    uint pos;
    uint lineNum;

    oper init(String contents, int lineNum) :
        contents = contents,
        lineNum = lineNum {
    }

    Token getToken() {
        AppendBuffer result = {128};
        const int
            BASE = 0,

            # A word is a sequence of non-whitespace chars which may contain
            # interpolation sequences.
            WORD = 1,

            BRACK = 2,
            BRACK_ESC = 3,

            VAR = 4,
            LIT_STR = 5,
            LIT_STR_ESC = 6,
            LIT_STR_HEX = 7,  # 7, 8 for first and second character
            LIT_STR_OCT = 9,  # 9, 10, 11 for up to three characters

            PRE_COMMENT = 12,
            COMMENT = 13,
            BACKSLASH = 14,
            CONSUME_FILE = 15;
        int state = BASE;

        # Accumulator for a hex or octal escape sequence.
        byte val;

        # Number of levels of curly bracket nesting.
        int count;

        # Line number at the start of the token.
        int startLineNum;

        while (true) {
            byte ch;
            if (pos == contents.size)
                ch = 0;
            else {
                ch = contents[pos++];
                if (ch == b'\n') lineNum++;
            }
            if (state == BASE) {
                if (!ch)
                    return Token(TOK_EOF, null, lineNum);
                if (ch == b'\n' || ch == b';')
                    return Token(TOK_SEMI, String(1, ch), lineNum);

                if (ch == b'{') {
                    state = BRACK;
                    startLineNum = lineNum;
                    count = 1;
                } else if (ch == b'$') {
                    state = VAR;
                    startLineNum = lineNum;
                } else if (ch == b'[') {
                    return Token(TOK_LBRACK, String(1, ch), lineNum);
                } else if (ch == b']') {
                    return Token(TOK_RBRACK, String(1, ch), lineNum);
                } else if (ch == b"'") {
                    state = LIT_STR;
                    startLineNum = lineNum;
                } else if (ch == b'#') {
                    state = PRE_COMMENT;
                } else if (ch == b'\\') {
                    state = BACKSLASH;
                } else if (!isSpace(ch)) {
                    result.append(ch);
                    state = WORD;
                }
            } else if (state == WORD) {
                if (isSpace(ch) || !ch || ch == b';') {
                    # Back up so we can catch it if it's a newline.
                    if (ch) --pos;
                    return Token(TOK_STR, String(result, true), lineNum);
                } else if (ch == b']') {
                    --pos;
                    return Token(TOK_STR, String(result, true), lineNum);
                } else {
                    result.append(ch);
                }
            } else if (state == BRACK) {
                if (ch == b'\\') {
                    state = BRACK_ESC;
                } else if (ch == b'{') {
                    ++count;
                } else if (ch == b'}') {
                    if (!--count)
                        return Token(TOK_STR, String(result, true),
                                     startLineNum
                                     );
                } else if (!ch) {
                    throw Exception('Premature end of file in bracketed '
                                    'string.');
                }
                result.append(ch);
            } else if (state == BRACK_ESC) {
                result.append(ch);
                state = BRACK;
            } else if (state == VAR) {
                if (ch >= b'a' && ch <= b'z' ||
                    ch >= b'A' && ch <= b'Z' ||
                    ch == b'_' || isDigit(ch)
                    ) {
                    result.append(ch);
                } else {
                    if (ch) --pos;
                    return Token(TOK_VAR, String(result, true), startLineNum);
                }
            } else if (state == LIT_STR) {
                if (ch == b'\\')
                    state = LIT_STR_ESC;
                else if (ch == b"'")
                    return Token(TOK_STR, String(result, true), startLineNum);
                else if (!ch)
                    throw Exception('Premature end of file in string literal.');
                else
                    result.append(ch);
            } else if (state == LIT_STR_ESC) {
                if (ch == b'n') {
                    ch = b'\n';
                } else if (ch == b't') {
                    ch = b'\t';
                } else if (ch == b'a') {
                    ch = b'\a';
                } else if (ch == b'r') {
                    ch = b'\r';
                } else if (ch == b'b') {
                    ch = b'\b';
                } else if (ch == b'x') {
                    state = LIT_STR_HEX;
                    val = 0;
                    continue;
                } else if (ch == b'o') {
                    state = LIT_STR_OCT;
                    val = 0;
                    continue;
                } else if (ch >= b'0' && ch <= b'7') {
                    state = LIT_STR_OCT + 1;
                    val = ch - b'0';
                    continue;
                }

                result.append(ch);
                state = LIT_STR;
            } else if (state >= LIT_STR_HEX && state < LIT_STR_OCT) {
                if (ch >= b'0' && ch <= b'9')
                    ch -= b'0';
                else if (ch >= b'a' && ch <= b'f')
                    ch = ch - b'a' + 10;
                else if (ch >= b'A' && ch <= b'F')
                    ch = ch - b'A' + 10;
                else {
                    # Not a legal hex character.  Add what we've got so far
                    # and switch to the next state.
                    result.append(val);
                    if (ch == b'\\') {
                        state = LIT_STR_ESC;
                        continue;
                    } else if (ch == b"'") {
                        return Token(TOK_STR, String(result, true), lineNum);
                    } else {
                        result.append(ch);
                        state = LIT_STR;
                        continue;
                    }
                }

                val = (val << 4) | ch;

                # Next character.
                ++state;
                if (state == LIT_STR_OCT) {
                    result.append(val);
                    state = LIT_STR;
                }
            } else if (state >= LIT_STR_OCT && state < PRE_COMMENT) {
                if (ch >= b'0' && ch <= b'7')
                    ch -= b'0';
                else {
                    # Not a legal octal character.
                    result.append(val);
                    if (ch == b'\\') {
                        state = LIT_STR_ESC;
                        continue;
                    } else if (ch == b"'") {
                        return Token(TOK_STR, String(result, true), lineNum);
                    } else {
                        result.append(ch);
                        state = LIT_STR;
                        continue;
                    }
                }

                val = (val << 3) | ch;

                ++state;
                if (state == PRE_COMMENT) {
                    result.append(val);
                    state = LIT_STR;
                    continue;
                }
            } else if (state == PRE_COMMENT) {
                if (ch == b'\n')
                    state = BASE;
                else if (ch == b'<')
                    state = CONSUME_FILE;
                else
                    state = COMMENT;
            } else if (state == COMMENT) {
                if (ch == b'\n')
                    state = BASE;
                else if (!ch)
                    return Token(TOK_EOF, null, lineNum);
            } else if (state == BACKSLASH) {
                if (ch == b'\n') {
                    state = BASE;
                } else {
                    result.append(ch);
                    state = WORD;
                }
            } else if (state == CONSUME_FILE) {
                if (ch)
                    result.append(ch);
                else
                    return Token(TOK_STR, String(result, true), lineNum);
            }
        }

        return null;
    }
}

class ParseContext {
    Block block = {};
    Command cmd;
    ParseContext parent;

    oper init() {}
    oper init(ParseContext parent) : parent = parent {}

    ## Adds a new term to the current command.
    void addTerm(Term term) {
        if (!cmd)
            cmd = Command(term);
        else
            cmd.args.append(term);
    }

    void endCommand() {
        if (cmd) {
            block.add(cmd);
            cmd = null;
        }
    }
}

class Parser {
    Toker toker;
    ParseContext context = ParseContext();

    oper init(String contents, int lineNum) : toker(contents, lineNum) {}
    oper init(String contents) : toker(contents, 1) {}

    ## Parse a block.  If 'topLevel', expect an EOF terminator, otherwise
    ## expect a right bracket (']').
    Block parseBlock(bool topLevel) {
        while (true) {
            tok := toker.getToken();
            if (tok.type == TOK_EOF) {
                if (!topLevel)
                    throw Exception('Premature EOF.');
                break;
            } else if (tok.type == TOK_STR) {
                context.addTerm(LiteralStringTerm(tok.text, SrcLoc(tok.lineNum)));
            } else if (tok.type == TOK_SEMI) {
                context.endCommand();
            } else if (tok.type == TOK_VAR) {
                context.addTerm(
                    VarRef(StringLiteral(tok.text, SrcLoc(tok.lineNum)))
                );
            } else if (tok.type == TOK_LBRACK) {
                context = ParseContext(context);
                result := InterpExpr(parseBlock(false));
                context = context.parent;
                context.addTerm(result);
            } else if (tok.type == TOK_RBRACK) {
                if (topLevel)
                    throw Exception(
                        FStr() I`line $(tok.lineNum): Closing bracket not \
                                 expected at this time.`
                    );
                break;
            } else {
                throw Exception(
                    FStr() I`line $(tok.lineNum): Token $(tok) not expected \
                             at this time.`
                );
            }
        }

        # Add the last command.
        context.endCommand();
        result := context.block;
        return result;
    }

    Block parse() {
        return parseBlock(true);
    }
}

## Parse a block out of a string.
Block parseString(String val) {
    return Parser(val).parse();
}

Block parseString(String val, int lineNum) {
    return Parser(val, lineNum).parse();
}

## Returns a new EvalContext containing all of the normal builtin functions.
EvalContext createRootContext() {
    ctx := EvalContext();
    ctx.define('print', PrintCmd());
    ctx.define('format', FormatCmd());
    ctx.define('give', GiveCmd());
    ctx.define('var', VarCmd());
    ctx.define('set', SetCmd());
    ctx.define('def', FuncDef());
    ctx.define('object', ObjectCmd());
    ctx.define('import', ImportCmd());
    ctx.define('evalfile', EvalfileCmd());
    ctx.define('load_module', LoadModuleCmd());
    ctx.define('source', SourceCmd());
    ctx.define('proc', ProcCmd());
    ctx.define('if', IfCmd());
    ctx.define('+', AddCmd());
    ctx.define('-', SubCmd());
    ctx.define('*', MulCmd());
    ctx.define('/', DivCmd());
    ctx.define('%', ModCmd());
    ctx.define('==', EqualCmd());
    ctx.define('!=', NotEqualCmd());
    return ctx;
}

Block compile(String expr) {
    Parser parser = {expr};
    return parser.parse();
}

Object eval(Block block, EvalContext context) {
    if (context is null)
        return block.evaluate(createRootContext());
    else
        return block.evaluate(context);
}

Object eval(Block block) { return eval(block, null); }

Object eval(String expr, EvalContext context) {
    block := compile(expr);
    return eval(block, context);
}

Object eval(String expr) { return eval(expr, null); }

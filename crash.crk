
import crack.ascii isDigit, isSpace, strip, wsplit;
import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.io cout, cerr, Formatter, FStr, StringFormatter;
import crack.lang AppendBuffer, Exception;
import crack.process Process;
import crack.strutil StringArray;
    
import types IntObj;

class EvalContext;

## A value stored in an EvalContext.  We don't store data values directly,
## they always are evaluated.  In this way, we can do things like override
## evaluation.
@abstract class Value {

    ## Returns the value of the object.
    @abstract Object evaluate(EvalContext context);

    ## Set the value.
    @abstract void set(Object value);

    ## Invoke the function associated with the value with the given arguments.
    @abstract Object invoke(EvalContext context, Array[Object] args);
}

## A variable dictionary.
class VarDict : HashMap[String, Value] {

    ## The parent of a VarDict is the VarDict of the context in which the 
    ## function is defined.
    VarDict parent;

    oper init() {}
    oper init(VarDict parent) : parent = parent {}

    @final Value lookUp(String name) {
        val := get(name, null);
        if (val is null) {
            if (parent != null)
                return parent.lookUp(name);
            else
                return null
        } else {
            return val;
        }
    }

    @final void define(String name, Value val) {
        this[name] = val;
    }

    @final void set(String name, Object val) {
        holder := lookUp(name);
        if (holder is null)
            throw Exception(FStr() I`Undefined variable $name can not be \
                                     set (use "var" instead)`
                            );
        holder.set(val);
    }
}    

# A stack frame.
class Frame {
    Frame parent;
    
    ## The variable dictionary.
    VarDict vars = {};

    ## The current block.
    Array[Value] block;

    ## The instruction pointer.  This is a an index into block indicating the
    ## next instruction to evaluated.
    uint ip;
    
    oper init() {}
    oper init(Frame parent) : parent = parent, vars = VarDict(parent.vars) {}
    oper init(Frame parent, VarDict vars) : parent = parent, vars = vars {}
}

class EvalContext {

    ## The current stack frame.
    Frame frame = {};

    ## Set this to true to cause evaluation to yield.
    bool yield;

    @final Value lookUp(String name) {
        return frame.vars.lookUp(name);
    }

    @final void define(String name, Value val) {
        frame.vars.define(name, val);
    }

    @final void set(String name, Object val) {
        frame.vars.set(name, val);
    }
    
    @final void pushFuncFrame() {
        frame = Frame(frame);
    }
    
    @final void pushFuncFrame(VarDict vars) {
        frame = Frame(frame, vars);
    }
    
    @final void popFuncFrame() {
        frame = frame.parent;
    }
}

class SimpleValue : Value {
    Object __val;

    oper init(Object val) : __val = val {}

    Object evaluate(EvalContext context) {
        return __val;
    }

    Object invoke(EvalContext context, Array[Object] args) {
        # Assume this is a Value.
        val := evaluate(context);
        func := Value.cast(val);
        return func.invoke(context, args);
    }

    void set(Object value) {
        __val = value;
    }
}

@abstract class Builtin : Value {
    Object evaluate(EvalContext context) {
        return this;
    }

    void set(Object val) {
        throw Exception('You can not set a builtin.');
    }
}

class PrintCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        for (arg :in args)
            cout `$arg`;
        return null;
    }
}

class FormatCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        StringFormatter tmp = {};
        for (arg :in args) {
            tmp `$arg`;
        }

        return tmp.string();
    }
}

## Run a Subprocess.
class ProcCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        StringArray argv = {};
        for (arg :in args)
            argv.append(FStr() `$arg`);
        return IntObj(Process(argv, 0).run() & 0xff);
    }
}

## "give" just returns the value of its first argument.
class GiveCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('"give" must have exactly one argument.');
        return args[0];
    }
}

class VarCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('usage: var <var> <value>');

        String var = String.cast(args[0], null);
        if (var is null)
            throw Exception('first argument of var must be a string');

        Object val = args[1];
        context.define(var, SimpleValue(val));
        return val;
    }
}

class SetCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 2)
            throw Exception('usage: set <var> <value>');

        String var = String.cast(args[0], null);
        if (var is null)
            throw Exception('first argument of set must be a string');

        Object val = args[1];
        context.set(var, val);
        return val;
    }
}

## A crash object - this has its own variable dictionary that is injected as a 
## stack frame when a method is invoked.
class Obj : Builtin {
    Obj parent;
    VarDict vars;

    oper init(VarDict vars) : vars = vars {}
    oper init() : vars() {}

    Object invoke(EvalContext context, Array[Object] args) {
        if (!args)
            return this;
        
        method := String.cast(args[0], null);
        if (!method)
            throw Exception('Method names must be strings.');
        
        methodObj := vars.lookUp(method);
        if (!methodObj)
            throw Exception(FStr() `Undefined method: $method`);
        
        context.pushFuncFrame(vars);
        Object result;
        try {
            result = methodObj.invoke(context, args.subarray(1));
        } catch (Exception ex) {
            context.popFuncFrame();
            throw Exception(ex.text);
        }
        context.popFuncFrame();
        
        return result;
    }
    
    ## Define a name in the object's variable dictionary.
    @final void define(String name, Value val) {
        vars.define(name, val);
    }
}

## A word of syntax.  Quoted strings, blocks, and barewords are all terms.
@abstract class Term {
    @abstract Object evaluate(EvalContext context);
}

## A single command.
class Command : Value {
    Term command;
    Array[Term] args = {};

    oper init(Term command) : command = command {}

    Value __getCommand(EvalContext context) {
        # Evaluate the command and convert its value to a string if it isn't
        # one already.
        # TODO: split Command into LiteralCommand and EvaledCommand.
        cmdobj := command.evaluate(context);
        
        # If the command is already a value, just return it.
        if (valobj := Value.cast(cmdobj, null))
            return valobj;
        
        # Convert it to a string and do a lookup.
        String cmdstr;
        if ( !(cmdstr = String.cast(cmdobj, null)) )
            cmdstr = FStr() `$cmdobj`;
        cmdVal := context.lookUp(cmdstr);
        if (!cmdVal)
            throw Exception(FStr() `Invalid command: $cmdstr\n`);
        
        return cmdVal;
    }

    Object evaluate(EvalContext context) {

        cmdVal := __getCommand(context);

        Array[Object] evaledArgs = {};
        for (arg :in args)
            evaledArgs.append(arg.evaluate(context));
        return cmdVal.invoke(context, evaledArgs);
    }

    # This is really just to implement Value's interface, but it has the
    # ineresting side-effect of letting us evaluate a command against a fully
    # evaluated set of arguments.
    Object invoke(EvalContext context, Array[Object] args) {
        cmdVal := __getCommand(context);
        return cmdVal.invoke(context, args);
    }

    void set(Object value) {
        throw Exception('You may not set the value of a command.');
    }

    void formatTo(Formatter out) {
        out `$command`;
        for (arg :in args)
            out ` $arg`;
    }
}

## A Block of commands.
class Block {
    Array[Value] commands = {};

    Object evaluate(EvalContext context) {
        context.yield = false;
        context.frame.block = commands;
        context.frame.ip = 0;
        Object result;
        while (context.frame.ip < commands.count()) {
            result = commands[context.frame.ip++].evaluate(context);
            if (context.yield)
                return null;
        }
        return result;
    }

    @final void add(Value value) {
        commands.append(value);
    }

    void formatTo(Formatter out) {
        for (cmd :in commands)
            out `$cmd\n`;
    }
}

## An interpolated command: [do something]
class InterpolatedCommand : Term {
    Block contents;

    Object evaluate(EvalContext context) {
        return contents.evaluate(context);
    }
}

## A string without variable interpolations.
class LiteralString : Term {
    String val;

    oper init(String val) : val = val {}

    Object evaluate(EvalContext context) {
        return val;
    }

    void formatTo(Formatter out) {
        out `$(val.getRepr())`;
    }
}

class VarRef : Term {
    String varName;

    oper init(String varName) : varName = varName {}

    Object evaluate(EvalContext context) {
        holder := context.lookUp(varName);
        if (!holder)
            throw Exception(FStr() `Undefined variable $varName`);
        return holder.evaluate(context);
    }

    void formatTo(Formatter out) {
        out `\$$varName`;
    }
}

## An interpolation expression - a block of the form "[ statements ... ]"  
## Evaluates the block and returns the result.
class InterpExpr : Term {
    Block block;
    oper init(Block block) : block = block {}

    Object evaluate(EvalContext context) {
        vars := context.frame.vars;
        context.pushFuncFrame();
        context.frame.vars.parent = vars;
        
        result := block.evaluate(context);
        if (!context.yield)
            context.popFuncFrame();
        
        return result;
    }
    
    void formatTo(Formatter out) {
        out `[$block]`;
    }
}

#class InterpolatedString : Term {
#    Array[StringTerm
#    String value;
#
#    Object evaluate(EvalContext context) {
#        AppendBuffer result = {};
#        pos := value.lfind('$');
#        if (pos)
#            result.extend(value.slice(0, pos));

class ActiveFunc : Value {
    ## The function name.
    String name;

    ## Carries around the VarDict from where the function was instantiated.
    VarDict ownerVars;

    Array[String] argVars;
    Block body;

    oper init(String name, VarDict ownerVars, Array[String] argVars, 
              Block body
              ) :
        name = name,
        ownerVars = ownerVars,
        argVars = argVars,
        body = body {
    }

    Object evaluate(EvalContext context) {
        return this;
    }
    
    Object invoke(EvalContext context, Array[Object] args) {
        # Make sure we have the right number of arguments.
        if (args.count() != argVars.count())
            throw Exception(FStr() I`Wrong number of arguments (\
                                     $(argVars.count()) expected).`
                            );

        # Push a new stack frame.
        context.pushFuncFrame();
        
        # Chain variable lookups to the parent.
        context.frame.vars.parent = ownerVars;
        
        # Define all of the argument variables with their values.
        for (argIter :on args)
            context.define(argVars[argIter.index], SimpleValue(argIter.elem()));
        
        # Evaluate the function.
        result := body.evaluate(context);
        
        # If the function wasn't yielded, clean up the stack frame.
        if (!context.yield)
            context.popFuncFrame();
        
        return result;
    }
    
    void set(Object value) {
        throw Exception('Can not set a function');
    }
    
    void formatTo(Formatter out) {
        out `func $argVars {\n$body}`
    }
}

Block parseString(String val);

## Parses a block argument.  Does not check for a valid index, but does verify 
## that the argument can be casted to a string.
Block parseBlockArg(Array[Object] args, int index) {
    argVal := String.cast(args[index], null);
    if (argVal is null)
        throw Exception('Block argument expected');
    return parseString(argVal);
}

## A function definition.  When invoked, these create an ActiveFunc.
class FuncDef : Value {
    Object evaluate(EvalContext context) {
        return this;
    }

    void set(Object value) {
        throw Exception('Can not set a function definition value.');
    }

    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 3)
            throw Exception(I'Bad function definition, should be def <args> \
                              <body>');
        name := String.cast(args[0]);
        funcArgs := wsplit(strip(String.cast(args[1])));
        body := parseBlockArg(args, 2);
        
        # If there are no args, wsplit gives us [''], so remove that.
        if (funcArgs[0] == '')
            funcArgs.delete(0);

        # Create a function and register it.
        result := ActiveFunc(name, context.frame.vars, funcArgs, body);
        context.define(name, result);
        
        return result;
    }
}

## Command to create an object.
class ObjectCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() != 1)
            throw Exception('Usage: object { statement... }');
        
        # Parse and evaluate the body, steal the variable dict from the 
        # resulting stack frame.
        body := parseBlockArg(args, 0);
        context.pushFuncFrame();
        try {
            body.evaluate(context);
        } catch (Exception ex) {
            context.popFuncFrame();
            throw Exception(ex.text);
        }
        vars := context.frame.vars;
        context.popFuncFrame();
        
        return Obj(vars);
    }
}

## Command to import a set of names from an object.
class ImportCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        if (args.count() < 2)
            throw Exception('Usage: import <object> <name> ...');
        
        obj := Obj.cast(args[0]);
        for (name :in args.subarray(1)) {
            nm := String.cast(name, null);
            context.define(nm, obj.vars[nm]);
        }
        return obj;
    }
}

class IfCmd : Builtin {
    Object invoke(EvalContext context, Array[Object] args) {
        argCount := args.count();
        if (argCount < 2)
            throw Exception('usage: if <cond-block> <true-block> '
                             '{[else|elif] ...}'
                            );
        cond := parseBlockArg(args, 0);
        trueBlock := parseBlockArg(args, 1);
        
        # Evaluate the condition.
        context.pushFuncFrame();
        result := cond.evaluate(context);
        if (result is null && context.yield)
            return null;
        else if (result) {
            # Result is true, evaluate the block.
            result = trueBlock.evaluate(context);
            if (!context.yield)
                context.popFuncFrame();
            return result;
        }
        
        # Evaluate elif/else.
        int index = 2;
        while (index < argCount) {
            kw := String.cast(args[index], null);
            if (kw == 'else') {
                # Make sure we have exactly one more argument.
                if (argCount < index + 2)
                    throw Exception(FStr() I`Missing block after 'else'`);
                else if (argCount != index + 2)
                    throw Exception(FStr() I`Extra arguments after else block: \
                                            $(args.subarray(index + 2))`
                                    );

                # Do the else block.
                block := parseBlockArg(args, index + 1);
                result := block.evaluate(context);
                if (!context.yield)
                    context.popFuncFrame();
                return result;
            } else if (kw == 'elif') {
                # Make sure we have at least two more arguments.
                if (argCount < index + 2)
                    throw Exception('Missing condition or block after "elif"');
                
                cond = parseBlockArg(args, index + 1);
                
                # XXX Somehow when we resume, we're going to need to start 
                # from this point instead of reevaluating the entire if 
                # statement.
                result = cond.evaluate(context);
                if (result is null && context.yield)
                    return null;
                
                if (result) {
                    block := parseBlockArg(args, index + 2);
                    result = block.evaluate(context);
                    if (!context.yield)
                        context.popFuncFrame();
                    return result;
                }
                
                index += 3;
            } else {
                cerr `$args, $index, $kw\n`;
                throw Exception("'else' or 'elif' expected");
            }
        }
        
        return null;
    }
}        

const int
    TOK_EOF = 0,
    TOK_STR = 1,
    TOK_SEMI = 2,
    TOK_VAR = 3,
    
    # Left and right square brackets.
    TOK_LBRACK = 4,
    TOK_RBRACK = 5;

class Token {
    int type;
    String text;

    oper init(int type, String text) : type = type, text = text {}
    
    void formatTo(Formatter out) {
        if (text)
            out `$text`;
        else if (type == TOK_EOF)
            out `<EOF>`;
        else
            out `:$type:`;
    }
}

class Toker {
    String contents;
    uint pos;

    oper init(String contents) : contents = contents {}

    Token getToken() {
        AppendBuffer result = {128};
        const int
            BASE = 0,

            # A word is a sequence of non-whitespace chars which may contain
            # interpolation sequences.
            WORD = 1,

            BRACK = 2,
            BRACK_ESC = 3,

            VAR = 4,
            LIT_STR = 5,
            LIT_STR_ESC = 6,
            LIT_STR_HEX = 7,  # 7, 8 for first and second character
            LIT_STR_OCT = 9,  # 9, 10, 11 for up to three characters

            COMMENT = 12;
        int state = BASE;
        
        # Accumulator for a hex or octal escape sequence.
        byte val;

        # Number of levels of curly bracket nesting.
        int count;

        while (true) {
            byte ch;
            if (pos == contents.size)
                ch = 0;
            else
                ch = contents[pos++];
            if (state == BASE) {
                if (!ch)
                    return Token(TOK_EOF, null);
                if (ch == b'\n' || ch == b';')
                    return Token(TOK_SEMI, String(1, ch));

                if (ch == b'{') {
                    state = BRACK;
                    count = 1;
                } else if (ch == b'$') {
                    state = VAR;
                } else if (ch == b'[') {
                    return Token(TOK_LBRACK, String(1, ch));
                } else if (ch == b']') {
                    return Token(TOK_RBRACK, String(1, ch));
                } else if (ch == b"'") {
                    state = LIT_STR;
                } else if (ch == b'#') {
                    state = COMMENT;
                } else if (!isSpace(ch)) {
                    result.append(ch);
                    state = WORD;
                }
            } else if (state == WORD) {
                if (isSpace(ch) || !ch || ch == b';') {
                    # Back up so we can catch it if it's a newline.
                    if (ch) --pos;
                    return Token(TOK_STR, String(result, true));
                } else if (ch == b']') {
                    --pos;
                    return Token(TOK_STR, String(result, true));
                } else {
                    result.append(ch);
                }
            } else if (state == BRACK) {
                if (ch == b'\\') {
                    state = BRACK_ESC;
                } else if (ch == b'{') {
                    ++count;
                } else if (ch == b'}') {
                    if (!--count)
                        return Token(TOK_STR, String(result, true));
                } else if (!ch) {
                    throw Exception('Premature end of file in bracketed '
                                    'string.');
                }
                result.append(ch);
            } else if (state == BRACK_ESC) {
                result.append(ch);
                state = BRACK;
            } else if (state == VAR) {
                if (ch >= b'a' && ch <= b'z' ||
                    ch >= b'A' && ch <= b'Z' ||
                    ch == b'_' || isDigit(ch)
                    ) {
                    result.append(ch);
                } else {
                    if (ch) --pos;
                    return Token(TOK_VAR, String(result, true));
                }
            } else if (state == LIT_STR) {
                if (ch == b'\\') 
                    state = LIT_STR_ESC;
                else if (ch == b"'")
                    return Token(TOK_STR, String(result, true));
                else if (!ch)
                    throw Exception('Premature end of file in string literal.');
                else
                    result.append(ch);
            } else if (state == LIT_STR_ESC) {
                if (ch == b'n') {
                    ch = b'\n';
                } else if (ch == b't') {
                    ch = b'\t';
                } else if (ch == b'a') {
                    ch = b'\a';
                } else if (ch == b'r') {
                    ch = b'\r';
                } else if (ch == b'b') {
                    ch = b'\b';
                } else if (ch == b'x') {
                    state = LIT_STR_HEX;
                    val = 0;
                    continue;
                } else if (ch == b'o') {
                    state = LIT_STR_OCT;
                    val = 0;
                    continue;
                } else if (ch >= b'0' && ch <= b'7') {
                    state = LIT_STR_OCT + 1;
                    val = ch - b'0';
                    continue;
                }

                result.append(ch);
                state = LIT_STR;
            } else if (state >= LIT_STR_HEX && state < LIT_STR_OCT) {
                if (ch >= b'0' && ch <= b'9')
                    ch -= b'0';
                else if (ch >= b'a' && ch <= b'f')
                    ch = ch - b'a' + 10;
                else if (ch >= b'A' && ch <= b'F')
                    ch = ch - b'A' + 10;
                else {
                    # Not a legal hex character.  Add what we've got so far 
                    # and switch to the next state.
                    result.append(val);
                    if (ch == b'\\') {
                        state = LIT_STR_ESC;
                        continue;
                    } else if (ch == b"'") {
                        return Token(TOK_STR, String(result, true));
                    } else {
                        result.append(ch);
                        state = LIT_STR;
                        continue;
                    }
                }

                val = (val << 4) | ch;
                
                # Next character.
                ++state;
                if (state == LIT_STR_OCT) {
                    result.append(val);
                    state = LIT_STR;
                }
            } else if (state >= LIT_STR_OCT && state < COMMENT) {
                if (ch >= b'0' && ch <= b'7')
                    ch -= b'0';
                else {
                    # Not a legal octal character.
                    result.append(val);
                    if (ch == b'\\') {
                        state = LIT_STR_ESC;
                        continue;
                    } else if (ch == b"'") {
                        return Token(TOK_STR, String(result, true));
                    } else {
                        result.append(ch);
                        state = LIT_STR;
                        continue;
                    }
                }
                
                val = (val << 3) | ch;
                
                ++state;
                if (state == COMMENT) {
                    result.append(val);
                    state = LIT_STR;
                    continue;
                }
            } else if (state == COMMENT) {
                if (ch == b'\n')
                    state = BASE;
                else if (!ch)
                    return Token(TOK_EOF, null);
            }
        }

        return null;
    }
}

class ParseContext {
    Block block = {};
    Command cmd;
    ParseContext parent;

    oper init() {}
    oper init(ParseContext parent) : parent = parent {}
    
    ## Adds a new term to the current command.
    void addTerm(Term term) {
        if (!cmd)
            cmd = Command(term);
        else
            cmd.args.append(term);
    }
    
    void endCommand() {
        if (cmd) {
            block.add(cmd);
            cmd = null;
        }
    }
}

class Parser {
    Toker toker;
    ParseContext context = ParseContext();

    oper init(String contents) : toker(contents) {}

    ## Parse a block.  If 'topLevel', expect an EOF terminator, otherwise 
    ## expect a right bracket (']').
    Block parseBlock(bool topLevel) {
        while (true) {
            tok := toker.getToken();
            if (tok.type == TOK_EOF) {
                if (!topLevel)
                    throw Exception('Premature EOF.');
                break;
            } else if (tok.type == TOK_STR) {
                context.addTerm(LiteralString(tok.text));
            } else if (tok.type == TOK_SEMI) {
                context.endCommand();
            } else if (tok.type == TOK_VAR) {
                context.addTerm(VarRef(tok.text));
            } else if (tok.type == TOK_LBRACK) {
                context = ParseContext(context);
                result := InterpExpr(parseBlock(false));
                context = context.parent;
                context.addTerm(result);
            } else if (tok.type == TOK_RBRACK) {
                if (topLevel)
                    throw Exception('Closing bracket not expected at this time.');
                break;
            } else {
                throw Exception(FStr() I`Token $(tok) not expected at this 
                                         time.`
                                );
            }
        }

        # Add the last command.
        context.endCommand();
        result := context.block;     
        return result;
    }
    
    Block parse() {
        return parseBlock(true);
    }
}

Block parseString(String val) {
    return Parser(val).parse();
}

## Returns a new EvalContext containing all of the normal builtin functions.
EvalContext createRootContext() {
    ctx := EvalContext();
    ctx.define('print', PrintCmd());
    ctx.define('format', FormatCmd());
    ctx.define('give', GiveCmd());
    ctx.define('var', VarCmd());
    ctx.define('set', SetCmd());
    ctx.define('def', FuncDef());
    ctx.define('object', ObjectCmd());
    ctx.define('import', ImportCmd());
    ctx.define('proc', ProcCmd());
    ctx.define('if', IfCmd());
    return ctx;
}

Block compile(String expr) {
    Parser parser = {expr};
    return parser.parse();
}

Object eval(Block block, EvalContext context) {
    if (context is null)
        return block.evaluate(createRootContext());
    else
        return block.evaluate(context);
}

Object eval(Block block) { return eval(block, null); }

Object eval(String expr, EvalContext context) {
    block := compile(expr);
    return eval(block, context);
}

Object eval(String expr) { return eval(expr, null); }

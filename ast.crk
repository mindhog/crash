# Copyright 2020 Google LLC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     https://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

## Crash 2 Abstract syntax tree.
##
## The AST should be normalized to remove extraneous enclosing nodes.  For
## example, a dynamic list consisting of a single expression should normalize
## to that expression (I can't think of another place where this comes into
## play).

import crack.cont.array Array;
import crack.cont.hashmap HashMap;
import crack.io cerr, Formatter, FStr;
import crack.lang cmp;

class SrcLoc;
SrcLoc _get(String filename, int row, int col);

## Records a source location.  These are immutable by design.
class SrcLoc {
    String __filename;
    int __row, __col;
    oper init(String filename, int row, int col) :
        __filename = filename,
        __row = row,
        __col = col {
    }

    int cmp(Object other) {
        if (o := SrcLoc.cast(other, null)) {
            rc := cmp(__filename, o.__filename);
            if (rc) return rc;
            rc = cmp(__row, o.__row);
            if (rc) return rc;
            rc = cmp(__col, o.__col);
            return rc;
        } else {
            return Object.cmp(other);
        }
    }

    uint makeHashVal() {
        return __filename.makeHashVal() ^ __row ^ __col;
    }

    int getRow() { return __row }
    int getCol() { return __col }

    void formatTo(Formatter out) {
        out `$__filename:$__row:$__col`;
    }

    ## Creates a new source location object
    @static SrcLoc get(String filename, int row, int col) {
        return _get(filename, row, col);
    }
}

HashMap[SrcLoc, SrcLoc] _srcLocs = {};
SrcLoc _get(String filename, int row, int col) {
    tmp := SrcLoc(filename, row, col);
    result := _srcLocs.get(tmp);
    if (!result) {
        _srcLocs.set(tmp, tmp);
        return tmp;
    } else {
        return result;
    }
}

class Node {
    SrcLoc loc;
    oper init(SrcLoc loc) : loc = loc {}
}

## Identifier.
class Ident : Node {
    String text;

    oper init(SrcLoc loc, String text) : Node(loc), text = text {}

    void formatTo(Formatter out) {
        out `$text`;
    }
}

## An expression.
## expression ::= literal | func_call | dynamic_list
class Expr : Node {
    oper init(SrcLoc loc) : Node(loc) {}
}

class FuncCall : Expr {
    Expr func;
    Array[Expr] args;

    oper init(SrcLoc loc, Expr func, Array[Expr] args) :
        Expr(loc),
        func = func,
        args = args {
    }

    void formatTo(Formatter out) {
        out `$func(`;
        bool notFirst;
        for (arg :in args) {
            if (notFirst) {
                out `, $arg`;
            } else {
                out `$arg`;
                notFirst = true;
            }
        }
        out `)`;
    }
}

## Variable reference.
class VarRef : Expr {
    Ident var;

    oper init(SrcLoc loc, Ident var) : Expr(loc), var = var {}

    void formatTo(Formatter out) {
        out `$var`;
    }
}

## A field reference.
class FieldRef : Expr {
    Expr primary;
    Ident field;

    oper init(SrcLoc loc, Expr primary, Ident field) :
        Expr(loc),
        primary = primary,
        field = field {
    }

    void formatTo(Formatter out) {
        out `$primary.$field`;
    }
}

class List : Expr {
    Array[Expr] _contents;

    oper init(SrcLoc loc, Array[Expr] contents) :
        Expr(loc),
        _contents = contents {
    }

    void formatTo(Formatter out) {
        bool notFirst;
        for (expr :in _contents) {
            if (notFirst) {
                out `; $expr`;
            } else {
                out `$expr`;
                notFirst = true;
            }
        }
    }

    Array[Expr] getElements() { return _contents }
}

class StringLiteral : Expr {
    String contents;
    oper init(SrcLoc loc, String contents) : Expr(loc), contents = contents {}

    void formatTo(Formatter out) {
        out `$(contents.getRepr())`;
    }
}

class IntegerLiteral : Expr {
    int val;
    oper init(SrcLoc loc, int val) : Expr(loc), val = val {}

    void formatTo(Formatter out) {
        out `$val`;
    }
}

class FloatLiteral : Expr {
    float64 val;
    oper init(SrcLoc loc, float64 val) : Expr(loc), val = val {}

    void formatTo(Formatter out) {
        out `$val`;
    }
}

## A list that is to be evaluated during the course of execution.
class DynamicList : List {
    oper init(SrcLoc loc, Array[Expr] contents) : List(loc, contents) {}

    void formatTo(Formatter out) {
        out `(`;
        List.formatTo(out);
        out `)`;
    }
}

## A list that is to be passed in to a function without being evaluated.
class StaticList : List {
    oper init(SrcLoc loc, Array[Expr] contents) : List(loc, contents) {}

    void formatTo(Formatter out) {
        out `{`;
        List.formatTo(out);
        out `}`;
    }
}

class IfStmt : Expr {
    Expr cond;

    StaticList
        ## Expression to be evaluated when true.
        onTrue,

        ## Expresssion to be evaluated when false.  May be null, in which case
        ## the if statement evaluates to the zero value of the onTrue result
        ## type.
        onFalse;

    oper init(SrcLoc loc, Expr cond, StaticList onTrue, StaticList onFalse) :
        Expr(loc),
        cond = cond,
        onTrue = onTrue,
        onFalse = onFalse {
    }

    void formatTo(Formatter out) {
        out `if `;
        if (cond.isa(DynamicList))
            out `$cond`;
        else
            out `($cond)`;
        out ` $onTrue`;
        if (onFalse) out ` else $onFalse`;
    }
}

class ForStmt : Expr {
    Expr initializer;
    StaticList
        ## Condition to predicate the evaluation of the block.  May be null,
        ## in which case the loop is performed forever (or until break).
        cond,

        ## Action to be performed after the block.
        doAfter,

        ## The main body of the loop.
        block;

    oper init(SrcLoc loc, Expr initializer, StaticList cond, StaticList doAfter,
              StaticList block
              ) :
        Expr(loc),
        initializer = initializer,
        cond = cond,
        doAfter = doAfter,
        block = block {
    }
}

## Type specifier.
class TypeSpec : Expr {
    oper init(SrcLoc loc) : Expr(loc) {}
}

## A named type.  This can be a simple variable name or
class NominalType : TypeSpec {
    Ident name;

    oper init(SrcLoc loc, Ident name) : TypeSpec(loc), name = name {}

    void formatTo(Formatter out) {
        out `$name`;
    }
}

## A type inferred from the type of an expression.
class InferredType : TypeSpec {
    Expr expr;

    oper init(SrcLoc loc, Expr expr) : TypeSpec(loc), expr = expr {}

    void formatTo(Formatter out) {
        out `@typeof($expr)`;
    }
}

class VarDef : Expr {

    ## Name of the variable to assign.
    Ident name;

    ## Variable type.  Nullable, if null the type is inferred from the
    ## initializer.
    TypeSpec type;

    ## Initializer expression for the variable.
    ## Nullable.
    Expr initializer;

    oper init(SrcLoc loc, Ident name, TypeSpec type, Expr initializer) :
        Expr(loc),
        name = name,
        type = type,
        initializer = initializer {
    }

    void formatTo(Formatter out) {
        out `$name :`;
        if (type)
            out ` $type$(initializer ? ' ' : '')`;
        if (initializer)
            out `= $initializer`;
    }
}

String str(Object obj) {
    return FStr() `$obj`;
}

class FuncDef : Expr {

    ## Function name (may be null for an anonymous function).
    Ident name;

    ## Argument list.
    Array[VarDef] args;

    ## Return type, may be null indicating that the return type was not
    ## specified and may be inferred.
    TypeSpec returnType;

    StaticList body;

    oper init(SrcLoc loc, Ident name, Array[VarDef] args, TypeSpec returnType,
              StaticList body
              ) :
        Expr(loc),
        name = name,
        args = args,
        returnType = returnType,
        body = body {
    }

    void formatTo(Formatter out) {
        out `func $(name ? str(name) : '')(`;
        bool notFirst;
        for (arg :in args) {
            if (notFirst) {
                out `, $arg`;
            } else {
                out `$arg`;
                notFirst = true;
            }
        }
        out `)$(returnType ? ' : ' + str(returnType) : '') $body`;
    }
}

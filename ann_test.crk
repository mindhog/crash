
import crack.cont.array Array;
import crack.io cout, cerr, Formatter;
import crack.lang cmp, Exception;
import crash createRootContext, eval, Builtin, EvalContext, Obj, Value;
import types IntObj, BoolObj, FloatObj;
import repl repl;

@import ann function;
@import crack.ann assert;

@function int strlen(String name) {
    return name.size;
}

@function float addPointFive(float val) {
    return val + 0.5;
}

@function bool negate(bool val) {
    return !val;
}

class Foo {
    alias Int = int;
}

@function(Foo.Int) int meth() {
    return self;
}

root := createRootContext();
root.define('strlen', strlen());
root.define('addPointFive', addPointFive());
root.define('negate', negate());

@function int getInt(int val) { return val }
root.define('getInt', getInt());
@function float getFloat(float val) { return val }
root.define('getFloat', getFloat());
@function bool getBool(bool val) { return val }
root.define('getBool', getBool());

# Define a method.
o := Obj();
o.define('meth', meth(100));
root.define('obj', o);

@assert(eval('strlen foobar', root) == IntObj(6));
@assert(eval('addPointFive 1.0', root) == FloatObj(1.5));
@assert(eval('$obj meth', root) == IntObj(100));

@assert(eval('getInt [getInt 100]', root) == IntObj(100));
@assert(eval('getFloat [getFloat 1.1]', root) == FloatObj(1.1));
@assert(eval('getBool [getBool true]', root) == BoolObj(true));

@function Obj makeObj() {
    class Foo {}

    @function(Foo) int die() {
        throw Exception('some text');
    }

    obj := Obj();
    obj.define('die', die(Foo()));

    return obj;
}

root.define('makeObj', makeObj());

try {
    eval('[makeObj] die', root);
    @assert(false);
} catch (Exception ex) {
    @assert(ex.text == 'some text');
}

# Test automatic conversion.
Value wrapFoo(EvalContext context, Object foo) {
    obj := Obj();
    self := Foo.cast(foo);
    @function(Foo) String method() { return 'ok' }
    obj.define('method', method(self));
    return obj;
}
@function Foo makeFoo() { return Foo() }
root.define('Foo', makeFoo());
root.defineConverter(Foo, wrapFoo);
@assert(eval('var f [Foo]; f method', root) == 'ok');
@assert(eval('[Foo] method', root) == 'ok');

cout `ok\n`;


